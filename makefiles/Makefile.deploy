##
##**************************************************
##* Makefile commands for containerized deployment *
##**************************************************
##


REMOTE_NAME_PROD=toxic_prod


.PHONY: backup.container
backup.container:  ## create remote database (running on host OS) backup in local directory
	docker --context=$(REMOTE_NAME_PROD) exec -i $$(docker --context=$(REMOTE_NAME_PROD) ps -f name=toxic_prod_db --quiet) \
		pg_dump --data-only --inserts -h localhost -d toxic -U toxic | gzip > "$(BACKUP_FILENAME)-host.sql.gz"
	du -sh ./backups/*


.PHONY: debug
debug:             ## start dependencies
	docker build -t slasyz/toxicbot/db:latest --progress plain ./db/
	docker build -t slasyz/toxicbot/app:latest --progress plain .
	docker stack deploy \
		--compose-file stack/base.yml \
		--compose-file stack/debug.yml \
		--prune toxic_local

.PHONY: attach
attach:            ## attach to empty debug container
	docker exec -i --tty $$(docker ps -f name=toxic_local_app --quiet) /bin/bash


.PHONY: _deploy
_deploy:
	@{ \
  		if [[ -z "$(ENV)" ]]; then \
			echo "Error: no environment specified."; \
			exit 1; \
		fi; \
	}
	docker --context "$(REMOTE_NAME)" build -t slasyz/toxicbot/db:latest --progress plain ./db/
	docker --context "$(REMOTE_NAME)" build -t slasyz/toxicbot/app:latest --progress plain .
	docker --context "$(REMOTE_NAME)" stack deploy \
		--compose-file stack/base.yml \
		--compose-file stack/$(ENV).yml \
		--prune toxic_$(ENV)

.PHONY: deploy.local
deploy.local:      ## run app in container locally
	make _deploy REMOTE_NAME="" ENV="local"

.PHONY: deploy.prod
deploy.prod:       ## run app in container remotely
	make _deploy REMOTE_NAME="$(REMOTE_NAME_PROD)" ENV="prod"


.PHONY: _init.container
_init.container:
	@{ \
  		if [[ -z "$(ENV)" ]]; then \
			echo "Error: no environment specified."; \
			exit 1; \
		fi; \
		if [[ -z "$$(docker secret ls | grep toxic_$(ENV)_postgres_database)" ]]; then \
			read -s -p "Please enter Postgres database: " postgres_database; \
			printf "$$postgres_database" | docker --context "$(REMOTE_NAME)" secret create toxic_$(ENV)_postgres_database -; \
		fi; \
		if [[ -z "$$(docker secret ls | grep toxic_$(ENV)_postgres_username)" ]]; then \
			read -s -p "Please enter Postgres username: " postgres_username; \
			printf "$$postgres_username" | docker --context "$(REMOTE_NAME)" secret create toxic_$(ENV)_postgres_username -; \
		fi; \
		if [[ -z "$$(docker secret ls | grep toxic_$(ENV)_postgres_password)" ]]; then \
			read -s -p "Please enter Postgres password: " postgres_password; \
			printf "$$postgres_password" | docker --context "$(REMOTE_NAME)" secret create toxic_$(ENV)_postgres_password -; \
		fi; \
	}
	docker --context "$(REMOTE_NAME)" build -t slasyz/toxicbot/db:latest --progress plain ./db/
	docker --context "$(REMOTE_NAME)" build -t slasyz/toxicbot/app:latest --progress plain .

.PHONY: init.local
init.local:        ## initialize stuff for container locally (secrets, ...)
	make _init.container REMOTE_NAME="" ENV="local"

.PHONY: init.prod
init.prod:         ## initialize stuff for container for production deployment (secrets, ...)
	make _init.container REMOTE_NAME="$(REMOTE_NAME_PROD)" ENV="prod"


.PHONY: logs.prod.db
logs.prod.db:      ## show database production logs
	docker --context $(REMOTE_NAME_PROD) logs --tail 50 --follow --timestamps $$(docker --context $(REMOTE_NAME_PROD) ps -f name=toxic_prod_db --quiet)

.PHONY: logs.prod.app
logs.prod.app:     ## show application production logs
	docker --context $(REMOTE_NAME_PROD) logs --tail 50 --follow --timestamps $$(docker --context $(REMOTE_NAME_PROD) ps -f name=toxic_prod_app --quiet)

.PHONY: stop.prod.app
stop.prod.app:     ## shop production app
	docker --context $(REMOTE_NAME_PROD) service rm toxic_prod_app

.PHONY: stop.local.app
stop.local.app:    ## stop local app
	docker service rm toxic_prod_app
