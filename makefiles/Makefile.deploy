##
##**************************************************
##* Makefile commands for containerized deployment *
##**************************************************
##


REMOTE_NAME_PROD=toxic_prod


.PHONY: backup.container
backup.container:  ## create remote database (running in container) backup in local directory
	docker --context=$(REMOTE_NAME_PROD) exec -i $$(docker --context=$(REMOTE_NAME_PROD) ps -f name=toxic_prod_db --quiet) \
		pg_dump --data-only --inserts -h localhost -d toxic -U toxic | gzip > "$(BACKUP_FILENAME)-container.sql.gz"
	du -sh ./backups/*


.PHONY: debug
debug:             ## start dependencies
	export ENV=local
	docker build -t slasyz/toxicbot/db:latest --progress plain ./db/
	docker build -t slasyz/toxicbot/app:latest --progress plain .
	docker stack deploy \
		--compose-file stack/base.yml \
		--compose-file stack/debug.yml \
		--prune toxic_local

.PHONY: debug.attach
debug.attach:      ## attach to empty debug container
	docker exec -i --tty $$(docker ps -f name=toxic_local_app --quiet) /bin/bash


.PHONY: tests.integration
tests.integration: ## run tests in container locally
	@{ \
		export ENV=tests; \
		docker build -t slasyz/toxicbot/db:latest --progress plain ./db/; \
		docker build -t slasyz/toxicbot/app:latest --progress plain .; \
		docker stack deploy \
			--compose-file stack/base.yml \
			--compose-file stack/tests.yml \
			--prune toxic_tests; \
	}
	# TODO: find out how to restart container automatically, so everything below could be simplified to:
	#  docker exec -i --tty $$(docker ps -f name=toxic_tests_app --quiet) /bin/bash -c "make test.all";
	@{ \
		container_old_id=$$(docker ps -f name=toxic_tests_app --quiet); \
		if [ -n "$$container_old_id" ]; then \
			echo "Stopping old container..."; \
			docker stop -t 2 $$container_old_id; \
		else \
		  	echo "Old container not found."; \
		fi; \
	}
	@{ \
		n=0; \
		container_id=; \
		echo "Starting new container..."; \
		until [ "$$n" -ge 20 ] || (  [ -n "$$container_id" ] ) \
		do \
			echo -n "$$n."; \
			container_id=$$(docker ps -f name=toxic_tests_app --quiet); \
			n=$$((n+1)); \
			sleep 1; \
		done; \
		if [ -n "$$container_id" ]; then \
			docker exec -i --tty $$container_id /bin/bash -c "make test.all"; \
		else \
			echo "Error: container was not started."; \
			exit 1; \
		fi; \
	}

.PHONY: _deploy
_deploy:
	@{ \
  		if [[ -z "$(ENV)" ]]; then \
			echo "Error: no environment specified."; \
			exit 1; \
		fi; \
	}
	export ENV=$(ENV)
	docker --context "$(REMOTE_NAME)" build -t slasyz/toxicbot/db:latest --progress plain ./db/
	docker --context "$(REMOTE_NAME)" build -t slasyz/toxicbot/app:latest --progress plain .
	docker --context "$(REMOTE_NAME)" stack deploy \
		--compose-file stack/base.yml \
		--compose-file stack/$(ENV).yml \
		--prune toxic_$(ENV)
	docker --context "$(REMOTE_NAME)" stop -t 5 $$(docker --context $(REMOTE_NAME_PROD) ps -f name=toxic_prod_app --quiet)

.PHONY: deploy.local
deploy.local:      ## run app in container locally
	make _deploy REMOTE_NAME="" ENV="local"

.PHONY: deploy.prod
deploy.prod:       ## run app in container remotely
	make _deploy REMOTE_NAME="$(REMOTE_NAME_PROD)" ENV="prod"


.PHONY: _init.container
_init.container:
	@{ \
  		if [[ -z "$(ENV)" ]]; then \
			echo "Error: no environment specified."; \
			exit 1; \
		fi; \
		if [[ -z "$$(docker secret ls | grep toxic_$(ENV)_postgres_database)" ]]; then \
			read -s -p "Please enter Postgres database: " postgres_database; \
			printf "$$postgres_database" | docker --context "$(REMOTE_NAME)" secret create toxic_$(ENV)_postgres_database -; \
		fi; \
		if [[ -z "$$(docker secret ls | grep toxic_$(ENV)_postgres_username)" ]]; then \
			read -s -p "Please enter Postgres username: " postgres_username; \
			printf "$$postgres_username" | docker --context "$(REMOTE_NAME)" secret create toxic_$(ENV)_postgres_username -; \
		fi; \
		if [[ -z "$$(docker secret ls | grep toxic_$(ENV)_postgres_password)" ]]; then \
			read -s -p "Please enter Postgres password: " postgres_password; \
			printf "$$postgres_password" | docker --context "$(REMOTE_NAME)" secret create toxic_$(ENV)_postgres_password -; \
		fi; \
		if [[ -z "$$(docker network ls -f name=infra | grep infra)" ]]; then \
			docker network create --scope=swarm infra; \
		fi; \
	}
	docker --context "$(REMOTE_NAME)" build -t slasyz/toxicbot/db:latest --progress plain ./db/
	docker --context "$(REMOTE_NAME)" build -t slasyz/toxicbot/app:latest --progress plain .

.PHONY: init.local
init.local:        ## initialize stuff for container locally (secrets, ...)
	make _init.container REMOTE_NAME="" ENV="local"

.PHONY: init.prod
init.prod:         ## initialize stuff for container for production deployment (secrets, ...)
	make _init.container REMOTE_NAME="$(REMOTE_NAME_PROD)" ENV="prod"


.PHONY: init.tests
init.tests:        ## initialize stuff for container for integration tests (secrets, ...)
	@{ \
		if [[ -z "$$(docker secret ls | grep toxic_tests_postgres_database)" ]]; then \
			printf "toxic" | docker secret create toxic_tests_postgres_database -; \
		fi; \
		if [[ -z "$$(docker secret ls | grep toxic_tests_postgres_username)" ]]; then \
			printf "toxic" | docker secret create toxic_tests_postgres_username -; \
		fi; \
		if [[ -z "$$(docker secret ls | grep toxic_tests_postgres_password)" ]]; then \
			printf "toxic" | docker secret create toxic_tests_postgres_password -; \
		fi; \
		if [[ -z "$$(docker network ls -f name=infra | grep infra)" ]]; then \
			docker network create --scope=swarm infra; \
		fi; \
	}
	docker build -t slasyz/toxicbot/db:latest --progress plain ./db/
	docker build -t slasyz/toxicbot/app:latest --progress plain .


.PHONY: logs.prod.db
logs.prod.db:      ## show database production logs
	docker --context $(REMOTE_NAME_PROD) logs --tail 50 --follow --timestamps $$(docker --context $(REMOTE_NAME_PROD) ps -f name=toxic_prod_db --quiet)

.PHONY: logs.prod.app
logs.prod.app:     ## show application production logs
	docker --context $(REMOTE_NAME_PROD) logs --tail 50 --follow --timestamps $$(docker --context $(REMOTE_NAME_PROD) ps -f name=toxic_prod_app --quiet)

.PHONY: stop.prod.app
stop.prod.app:     ## shop production app
	docker --context $(REMOTE_NAME_PROD) service rm toxic_prod_app

.PHONY: stop.local.app
stop.local.app:    ## stop local app
	docker service rm toxic_prod_app
